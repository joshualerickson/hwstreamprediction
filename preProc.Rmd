---
title: "FFS RF without 3rd and 4th Orders"
author: "Josh Erickson"
date: "April 14, 2020"
output: html_document
---

```{r setup, include=FALSE}

library(sf)
library(sp)
library(raster)
library(automap)
library(caret)
library(CAST)
library(blockCV)
library(tidyverse)
library(gridExtra)
library(reshape2)
library(doParallel)
library(parallel)
library(mlbench)
library(plotROC)
library(pdp)
library(vip)
library(gridGraphics)
library(grid)
library(nhdplusTools)
library(mapproj)
```

**Now bring in all the TIFs to be used in the anlaysis and stack/visualise.**
```{r, eval = FALSE}
library(raster)


twi30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/twi30agg.tif") #TWI

vvsd30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/vvsd30agg.tif") #vertical vertical sd

vv30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/vv30agg.tif") #vertical vertical mean

npol30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/npol30agg.tif") #normalized polarization 

accum30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/accum30.tif") #UAA d-infinity aggregated from 10-m

nppMid30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/nppmmid30agg.tif") #NPP median '86-18'

deficit <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/deficitRS.tif") # annual CWD 30 yr

wtrbdy30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/wtrbdy30agg.tif") #waterbodies

tpi30 <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/tpi30agg.tif") #TPI

HDI <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/hdi30RS.tif") #hydrologic deficit index

CAD <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/cad30RS.tif") #cold air drainage

decid <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/decid30RS.tif") #deciduous

Blue <- raster("Blue_med.tif") #blue (B2)

Green <- raster("Green_med.tif") #green (B3)

Red <- raster("Red_med.tif") #red (B4)

NIR <- raster("NIR_med.tif") #Near Infrared (B8)

NDVI <-  raster("NDVI_med.tif")
  
NDWI <-  raster("NDWI_med.tif")

cpgPrecip <- raster("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_Workflow/cpg30precip.tif") #Continuous parameter grid (precipitation/PRISM).


topo_opt_rad34 <- stack(twi30, tpi30, accum30,vv30, vvsd30, npol30,  NDVI, NDWI, nppMid30, deficit, CAD, decid, Blue, Green, Red, NIR, cpgPrecip)
```


```{r, eval=TRUE}

plot(topo_opt_rad34, maxnl=32, nc = 4, legend = FALSE)

```

**Extract points from stack `topo_opt_rad30` and then combined with `pts`.**
```{r, eval = TRUE}

#combine point objects
proj.study <- "+proj=aea +lat_1=46 +lat_2=48 +lat_0=44 +lon_0=-109.5 +x_0=600000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"

pts34 <- read_sf("D:/Rcodes/Water_Prediction/Hird_Water_Prediction/waterD/waterPred/Final_workflow/points_spaced30m.shp")  #points to the folder/feature

st_crs(pts34) <- proj.study

pts34 <- st_transform(pts34, crs = proj.study)

#clean up

pts34 <- pts34[,c(2)]

```

```{r, eval=FALSE}

#Get forest service boundary
FSland <- read_sf("knf_ownership.shp")
FSland <- FSland[FSland$OWNER == 'FS',]

FSland <- st_transform(FSland, proj.study)

#Get District Boundary
DistrictBoundary <- read_sf("hw_study.gpkg", "DistrictBoundary")

DistrictBoundary <- st_transform(DistrictBoundary, proj.study)
#now intersect
landClip <- st_intersection(FSland, DistrictBoundary)

#read in the landClip we created and call it FSland
FSland <- read_sf("hw_study.gpkg", "landClip")

plot(FSland)

##st_write(landClip, 'hw_study.gpkg', "LandClip", driver = "ESRI Shapefile", update = TRUE)
##st_write(DistrictBoundary, 'hw_study.gpkg', "DistrictBoundary", driver = "ESRI Shapefile")
```

Now get NHDPlus

```{r}

download_dir <- download_nhdplushr(nhd_dir = getwd(), c("1701"))
nhdPlushr <- get_nhdplushr(getwd(), "nhdplus.gpkg",
layers = "NHDFlowline", overwrite = TRUE, proj = "+proj=aea +lat_1=46 +lat_2=48 +lat_0=44 +lon_0=-109.5 +x_0=600000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
nhdDistrict <- nhdPlushr$NHDFlowline
nhdDistrict <- st_transform(nhdDistrict, "+proj=aea +lat_1=46 +lat_2=48 +lat_0=44 +lon_0=-109.5 +x_0=600000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")
nhdDistrict <- st_crop(nhdDistrict, c(xmin = 150035.8, xmax = 222365.8, 
                                      ymin = 507390, ymax = 574500 ))
plot(nhdDistrict["StreamOrde"], main = "NHDPlus High Res with Stream Order")

nhdDistrictSF <- st_as_sf(nhdDistrict)
st_write(nhdDistrictSF, "hw_study.gpkg", "nhdDistrictSF")

nhdDistrictSF <- st_read("hw_study.gpkg", "nhdDistrictSF")
#now make a 30m raster with streamorder

ndhStrOrdRast <- rasterize(nhdDistrict, tpi30, field = "StreamOrde")

writeRaster(ndhStrOrdRast, "nhdStrOrdRast.tiff")

nhdStrOrdRast <- raster("nhdStrOrdRast.tif")
```


```{r}
#sample space area sq/km
area_sum <- sum(st_area(FSland$geom))

area_km <- area_sum/1000000


#add nhd raster
topo_opt_rad34 <- addLayer(topo_opt_rad34, nhdStrOrdRast)

thrty.34 <- mask(topo_opt_rad34, wtrbdy30, inverse = TRUE) #mask out waterbodies if you want

thrty.34 <- mask(thrty.34, FSland) #mask out non-Forest Service land

thrty.34 <- raster::extract(thrty.34, pts34) #extract the values from raster by point data

top34.opt.rad <- cbind(pts34, thrty.34)

top34.opt.rad2 <- cbind(pts34, thrty.34)

#get long lat for graphing
top34.opt.rad2 <- st_transform(top34.opt.rad2, crs = "+proj=longlat +datum=WGS84 +no_defs")

top34coords <- do.call(rbind, st_geometry(top34.opt.rad)) %>% 
    as_tibble() %>% setNames(c("utm1","utm2"))

top34lonlat <- do.call(rbind, st_geometry(top34.opt.rad2)) %>% 
    as_tibble() %>% setNames(c("lon","lat"))

st_geometry(top34.opt.rad) <- NULL

top34.opt.rad <- data.frame(cbind(top34.opt.rad,top34coords, top34lonlat))



write.csv(top34.opt.rad, file = "top34.opt.rad.csv")
```

```{r, eval=FALSE}
top34.opt.rad <- read.csv("top34.opt.rad.csv", header = TRUE)[-1]

data34 <- top34.opt.rad #change for ease

#change names
names(data34)[1] <- "stream"

names(data34)[19] <- "NHDPlus"

data34$stream <- factor(data34$stream)

data34$NHDPlus[is.na(data34$NHDPlus)] <- 0

data34 <- na.omit(data34)

data34 <- data34 %>% filter(NHDPlus < 3)

# write csv

write.csv(data34, file = "data34.csv")

```

```{r}

summary(data34)
data34 %>% select(Blue_med, Red_med, Green_med, NIR_med)  %>% gather(key, value) %>% ggplot() + geom_boxplot(aes(value, color = key)) + coord_flip()



```

```{r echo=FALSE, fig.align='center'}

data34 %>% mutate_at(vars(accum30), log) %>% select(npol30agg, accum30) %>% gather(key, value) %>% ggplot() + geom_boxplot(aes(value)) + coord_flip() + facet_wrap(~key, scales = "free_y")






```


```{r eval=FALSE}
data34 <- data34[!data34$npol30agg < -1,]
data34 <- data34[!data34$npol30agg > 1,]
```

Now look at the new boxplot and histogram for `npol30agg`, which looks much better.

```{r echo=FALSE, fig.align='center'}
#now look at boxplot
data34 %>% select(npol30agg) %>% gather(key, value) %>% ggplot() + geom_boxplot(aes(value)) + coord_flip()
#much better
```

After visualising, we can take a deeper look and search the data frame for correlation using a certain threshold (e.g., 90%). This is possible by  `caret`'s function called `findCorrelation`. This is the cutoff threshold that @hird2017google and @lidberg2020using used.

```{r fig.align='center'}
library(corrplot)
library(caret)
correlations34 <- cor(data34[,-c(1,9,19,20,21,22,23)]) #remove response and coords and NHDPlus
corrplot(correlations34, order = "hclust")

highCorr34 <- findCorrelation(correlations34, cutoff = 0.9)
highCorr34
```



There is one variable recommended to be taken out. Let's see what they are. 

```{r}
colnames(correlations34)[c(14,12)]
```

We ended up taking out NDWI_med, Blue_med, Red_med
```{r eval=FALSE}
data34 <- data34[, -which(names(data34) %in% c("NDWI_med", "Blue_med", "Red_med"))]

```

```{r, out.width= "70%", fig.align='center', message=FALSE}

barplot(prop.table(table(pts34$copy_TWI_1)),
        main = "Proportion of stream occurence", 
        names.arg = c("No Stream", "Stream"), ylab = "Proportion %") 
```
```{r, eval=TRUE, echo=FALSE}
kableExtra::kable(addmargins(table(Stream = pts34$copy_TWI_1)), caption = "Count")
kableExtra::kable(round(prop.table(table(Stream = pts34$copy_TWI_1)),3), caption = "Proportion")
```

First we want to bring in our point data and our covariates. 
```{r, eval=FALSE}
library(sf)
ptsSF34 <- st_as_sf(data34, coords = c("utm1","utm2"))

st_crs(ptsSF34) <- "+proj=aea +lat_1=46 +lat_2=48 +lat_0=44 +lon_0=-109.5 +x_0=600000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"
nrow(data34)
topo_new34 <- dropLayer(topo_opt_rad34, c("Blue_med", "Red_med", "NDWI_med")) #covariate stack
topo_new34
```

Now we can figure out our 'effictive range of spatial autocorrelation' by using the function `spatialAutoRange` in `blockCV`. This is a cool function because it takes the covariates, calculates the range of autocorrelation (from $n$ sampled points), and then produces two plots showing the range of the covariates and the recommended block size for validation.  

```{r eval=FALSE}

sac34 <- blockCV::spatialAutoRange(rasterLayer = topo_new34,
                                 sampleNumber = 5000,
                                 doParallel = TRUE,
                                 showPlots = TRUE)

```

```{r, echo=FALSE, fig.align="center"}

plot(sac34)

```



Finally, we can do a `kmeans` with a cluster of 80. This will be our small structure attempt.

```{r eval = FALSE}
#this is the k-means method (using a cluster of 20)
#need coordinates.
#remember to use the coordinates, that's why we've kept them!

Mycluster80 <- kmeans(data34[,c(20,21)], (nrow(data34)/80)) 

# add the new variable back to your dataframe here
data34$spatial_cluster80 = Mycluster80$cluster

ptsSF34$spatial_cluster80 = data34$spatial_cluster80
```

Now you can see the clusters and check the distribution

```{r, echo=FALSE, fig.align="center"}
#just to visualize!

ggplot() + geom_sf(data = ptsSF34, aes(color = spatial_cluster80)) 

#or

data34 %>%
ggplot(aes(lon,lat, color = spatial_cluster80)) +
  geom_point() +
  borders("state") + 
  coord_map(xlim = c(-110, -125), ylim = c(44,49)) + 
  theme_void()
  

data34 %>% count(spatial_cluster80) %>% map(., mean)

data34 %>% count(spatial_cluster80) %>% map(., median)

data34 %>% count(spatial_cluster80) %>% map(., sd)
```

